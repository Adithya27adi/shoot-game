<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Space Shooter Game</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap');

        body {
            font-family: 'Orbitron', monospace;
            background: linear-gradient(45deg, #0f0f0f, #1a1a2e, #16213e);
            background-size: 400% 400%;
            animation: gradientShift 8s ease infinite;
        }

        @keyframes gradientShift {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        #gameCanvas {
            cursor: crosshair;
            box-shadow: 0 0 30px rgba(147, 51, 234, 0.5);
        }

        .explosion {
            position: absolute;
            width: 20px;
            height: 20px;
            background: radial-gradient(circle, #ff6b35, #f7931e);
            border-radius: 50%;
            animation: explode 0.5s ease-out forwards;
        }

        @keyframes explode {
            0% {
                transform: scale(0);
                opacity: 1;
            }
            100% {
                transform: scale(3);
                opacity: 0;
            }
        }

        button:hover {
            box-shadow: 0 0 20px rgba(59, 130, 246, 0.5);
        }

        .score-pop {
            animation: scorePop 0.3s ease-out;
        }

        @keyframes scorePop {
            0% { transform: scale(1); }
            50% { transform: scale(1.2); }
            100% { transform: scale(1); }
        }
    </style>
</head>
<body class="bg-black min-h-screen flex items-center justify-center font-mono">
    <!-- Game Container -->
    <div class="relative bg-gradient-to-b from-gray-900 via-purple-900 to-black rounded-xl shadow-2xl border border-purple-500">
        <!-- Game Header -->
        <div class="bg-gray-800 rounded-t-xl p-4 border-b border-purple-500">
            <div class="flex justify-between items-center text-white">
                <div class="flex items-center space-x-4">
                    <div class="text-green-400 font-bold">Score: <span id="score">0</span></div>
                    <div class="text-blue-400 font-bold">Lives: <span id="lives">3</span></div>
                </div>
                <div class="text-yellow-400 font-bold">Level: <span id="level">1</span></div>
            </div>
        </div>

        <!-- Game Canvas -->
        <canvas id="gameCanvas" width="800" height="600" 
                class="block border-2 border-purple-500 bg-gradient-to-b from-blue-900 to-black">
        </canvas>

        <!-- Game Controls -->
        <div class="bg-gray-800 rounded-b-xl p-4 border-t border-purple-500">
            <div class="flex justify-center space-x-4">
                <button id="startBtn" 
                        class="bg-green-500 hover:bg-green-600 text-white px-6 py-2 rounded-lg font-bold transition-all transform hover:scale-105">
                    Start Game
                </button>
                <button id="pauseBtn" 
                        class="bg-yellow-500 hover:bg-yellow-600 text-white px-6 py-2 rounded-lg font-bold transition-all transform hover:scale-105">
                    Pause
                </button>
                <button id="restartBtn" 
                        class="bg-red-500 hover:bg-red-600 text-white px-6 py-2 rounded-lg font-bold transition-all transform hover:scale-105">
                    Restart
                </button>
            </div>
            <div class="text-center mt-4 text-gray-300 text-sm">
                Use WASD or Arrow keys to move, Space to shoot, Mouse to aim
            </div>
        </div>

        <!-- Game Over Screen -->
        <div id="gameOverScreen" 
             class="absolute inset-0 bg-black bg-opacity-80 flex items-center justify-center rounded-xl hidden">
            <div class="text-center text-white">
                <h2 class="text-4xl font-bold mb-4 text-red-500">Game Over</h2>
                <p class="text-xl mb-6">Final Score: <span id="finalScore">0</span></p>
                <button id="playAgainBtn" 
                        class="bg-blue-500 hover:bg-blue-600 text-white px-8 py-3 rounded-lg font-bold transition-all transform hover:scale-105">
                    Play Again
                </button>
            </div>
        </div>
    </div>

    <script>
        class Player {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.width = 40;
                this.height = 40;
                this.speed = 5;
                this.angle = 0;
                this.shootCooldown = 0;
            }

            update(keys, mouse) {
                // Movement
                if (keys['a'] || keys['arrowleft']) this.x -= this.speed;
                if (keys['d'] || keys['arrowright']) this.x += this.speed;
                if (keys['w'] || keys['arrowup']) this.y -= this.speed;
                if (keys['s'] || keys['arrowdown']) this.y += this.speed;

                // Boundaries
                this.x = Math.max(this.width/2, Math.min(game.width - this.width/2, this.x));
                this.y = Math.max(this.height/2, Math.min(game.height - this.height/2, this.y));

                // Calculate angle to mouse
                this.angle = Math.atan2(mouse.y - this.y, mouse.x - this.x);

                // Update cooldown
                if (this.shootCooldown > 0) this.shootCooldown--;
            }

            shoot() {
                if (this.shootCooldown <= 0) {
                    const bullet = new Bullet(this.x, this.y, this.angle);
                    game.bullets.push(bullet);
                    this.shootCooldown = 10;
                }
            }

            draw(ctx) {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.angle + Math.PI/2);
                
                // Draw player ship
                ctx.fillStyle = '#00ff88';
                ctx.beginPath();
                ctx.moveTo(0, -this.height/2);
                ctx.lineTo(-this.width/3, this.height/2);
                ctx.lineTo(0, this.height/3);
                ctx.lineTo(this.width/3, this.height/2);
                ctx.closePath();
                ctx.fill();
                
                // Engine glow
                ctx.fillStyle = '#ff4444';
                ctx.beginPath();
                ctx.arc(0, this.height/2, 5, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.restore();
            }
        }

        class Bullet {
            constructor(x, y, angle) {
                this.x = x;
                this.y = y;
                this.angle = angle;
                this.speed = 8;
                this.radius = 3;
            }

            update() {
                this.x += Math.cos(this.angle) * this.speed;
                this.y += Math.sin(this.angle) * this.speed;
            }

            draw(ctx) {
                ctx.fillStyle = '#ffff00';
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fill();
                
                // Bullet trail
                ctx.strokeStyle = '#ffaa00';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(this.x, this.y);
                ctx.lineTo(this.x - Math.cos(this.angle) * 10, this.y - Math.sin(this.angle) * 10);
                ctx.stroke();
            }

            isOffScreen() {
                return this.x < 0 || this.x > game.width || this.y < 0 || this.y > game.height;
            }
        }

        class Enemy {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.width = 30;
                this.height = 30;
                this.speed = 2 + Math.random() * 2;
                this.health = 1;
                this.angle = Math.random() * Math.PI * 2;
            }

            update() {
                // Move towards player
                const dx = game.player.x - this.x;
                const dy = game.player.y - this.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance > 0) {
                    this.x += (dx / distance) * this.speed;
                    this.y += (dy / distance) * this.speed;
                }
                
                this.angle += 0.1;
            }

            draw(ctx) {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.angle);
                
                // Draw enemy
                ctx.fillStyle = '#ff4444';
                ctx.fillRect(-this.width/2, -this.height/2, this.width, this.height);
                
                // Enemy details
                ctx.fillStyle = '#aa0000';
                ctx.fillRect(-this.width/4, -this.height/4, this.width/2, this.height/2);
                
                ctx.restore();
            }

            takeDamage() {
                this.health--;
                return this.health <= 0;
            }
        }

        class Particle {
            constructor(x, y, color) {
                this.x = x;
                this.y = y;
                this.vx = (Math.random() - 0.5) * 10;
                this.vy = (Math.random() - 0.5) * 10;
                this.life = 30;
                this.maxLife = 30;
                this.color = color;
                this.size = Math.random() * 5 + 2;
            }

            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.vx *= 0.98;
                this.vy *= 0.98;
                this.life--;
            }

            draw(ctx) {
                const alpha = this.life / this.maxLife;
                ctx.globalAlpha = alpha;
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size * alpha, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1;
            }

            isDead() {
                return this.life <= 0;
            }
        }

        class Game {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.width = this.canvas.width;
                this.height = this.canvas.height;
                
                this.player = null;
                this.bullets = [];
                this.enemies = [];
                this.particles = [];
                
                this.score = 0;
                this.lives = 3;
                this.level = 1;
                this.gameRunning = false;
                this.gamePaused = false;
                
                this.keys = {};
                this.mouse = { x: 0, y: 0 };
                
                this.enemySpawnTimer = 0;
                this.enemySpawnDelay = 120;
                
                this.init();
            }
            
            init() {
                this.player = new Player(this.width / 2, this.height - 50);
                this.setupEventListeners();
                this.setupUI();
            }
            
            setupEventListeners() {
                document.addEventListener('keydown', (e) => {
                    this.keys[e.key.toLowerCase()] = true;
                    if (e.key === ' ') {
                        e.preventDefault();
                        if (this.gameRunning) this.player.shoot();
                    }
                });
                
                document.addEventListener('keyup', (e) => {
                    this.keys[e.key.toLowerCase()] = false;
                });
                
                this.canvas.addEventListener('mousemove', (e) => {
                    const rect = this.canvas.getBoundingClientRect();
                    this.mouse.x = e.clientX - rect.left;
                    this.mouse.y = e.clientY - rect.top;
                });
                
                this.canvas.addEventListener('click', () => {
                    if (this.gameRunning) this.player.shoot();
                });
            }
            
            setupUI() {
                document.getElementById('startBtn').addEventListener('click', () => this.start());
                document.getElementById('pauseBtn').addEventListener('click', () => this.togglePause());
                document.getElementById('restartBtn').addEventListener('click', () => this.restart());
                document.getElementById('playAgainBtn').addEventListener('click', () => this.restart());
            }
            
            start() {
                this.gameRunning = true;
                this.gameLoop();
            }
            
            togglePause() {
                this.gamePaused = !this.gamePaused;
                if (!this.gamePaused && this.gameRunning) {
                    this.gameLoop();
                }
            }
            
            restart() {
                this.score = 0;
                this.lives = 3;
                this.level = 1;
                this.bullets = [];
                this.enemies = [];
                this.particles = [];
                this.player = new Player(this.width / 2, this.height - 50);
                this.enemySpawnTimer = 0;
                this.updateUI();
                document.getElementById('gameOverScreen').classList.add('hidden');
                this.gameRunning = true;
                this.gamePaused = false;
                this.gameLoop();
            }
            
            gameLoop() {
                if (!this.gameRunning || this.gamePaused) return;
                
                this.update();
                this.render();
                
                requestAnimationFrame(() => this.gameLoop());
            }
            
            update() {
                this.player.update(this.keys, this.mouse);
                
                // Update bullets
                this.bullets = this.bullets.filter(bullet => {
                    bullet.update();
                    return !bullet.isOffScreen();
                });
                
                // Spawn enemies
                this.enemySpawnTimer++;
                if (this.enemySpawnTimer >= this.enemySpawnDelay) {
                    this.spawnEnemy();
                    this.enemySpawnTimer = 0;
                    this.enemySpawnDelay = Math.max(30, this.enemySpawnDelay - 1);
                }
                
                // Update enemies
                this.enemies.forEach(enemy => enemy.update());
                
                // Update particles
                this.particles = this.particles.filter(particle => {
                    particle.update();
                    return !particle.isDead();
                });
                
                // Collision detection
                this.checkCollisions();
                
                // Check game over
                if (this.lives <= 0) {
                    this.gameOver();
                }
            }
            
            spawnEnemy() {
                const side = Math.floor(Math.random() * 4);
                let x, y;
                
                switch(side) {
                    case 0: x = Math.random() * this.width; y = -30; break;
                    case 1: x = this.width + 30; y = Math.random() * this.height; break;
                    case 2: x = Math.random() * this.width; y = this.height + 30; break;
                    case 3: x = -30; y = Math.random() * this.height; break;
                }
                
                this.enemies.push(new Enemy(x, y));
            }
            
            checkCollisions() {
                // Bullet vs Enemy
                for (let i = this.bullets.length - 1; i >= 0; i--) {
                    for (let j = this.enemies.length - 1; j >= 0; j--) {
                        const bullet = this.bullets[i];
                        const enemy = this.enemies[j];
                        
                        const dx = bullet.x - enemy.x;
                        const dy = bullet.y - enemy.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        if (distance < bullet.radius + enemy.width/2) {
                            // Create explosion particles
                            for (let k = 0; k < 10; k++) {
                                this.particles.push(new Particle(enemy.x, enemy.y, '#ff4444'));
                            }
                            
                            this.bullets.splice(i, 1);
                            this.enemies.splice(j, 1);
                            this.score += 10;
                            this.updateUI();
                            break;
                        }
                    }
                }
                
                // Player vs Enemy
                for (let i = this.enemies.length - 1; i >= 0; i--) {
                    const enemy = this.enemies[i];
                    const dx = this.player.x - enemy.x;
                    const dy = this.player.y - enemy.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance < this.player.width/2 + enemy.width/2) {
                        // Create explosion particles
                        for (let k = 0; k < 15; k++) {
                            this.particles.push(new Particle(enemy.x, enemy.y, '#ffaa00'));
                        }
                        
                        this.enemies.splice(i, 1);
                        this.lives--;
                        this.updateUI();
                    }
                }
            }
            
            render() {
                // Clear canvas with gradient
                const gradient = this.ctx.createLinearGradient(0, 0, 0, this.height);
                gradient.addColorStop(0, '#001122');
                gradient.addColorStop(1, '#000011');
                this.ctx.fillStyle = gradient;
                this.ctx.fillRect(0, 0, this.width, this.height);
                
                // Draw stars
                this.ctx.fillStyle = '#ffffff';
                for (let i = 0; i < 50; i++) {
                    const x = (i * 16) % this.width;
                    const y = (i * 23) % this.height;
                    this.ctx.fillRect(x, y, 1, 1);
                }
                
                // Draw game objects
                this.player.draw(this.ctx);
                this.bullets.forEach(bullet => bullet.draw(this.ctx));
                this.enemies.forEach(enemy => enemy.draw(this.ctx));
                this.particles.forEach(particle => particle.draw(this.ctx));
            }
            
            updateUI() {
                document.getElementById('score').textContent = this.score;
                document.getElementById('lives').textContent = this.lives;
                document.getElementById('level').textContent = this.level;
            }
            
            gameOver() {
                this.gameRunning = false;
                document.getElementById('finalScore').textContent = this.score;
                document.getElementById('gameOverScreen').classList.remove('hidden');
            }
        }

        // Initialize game
        const game = new Game();
    </script>
</body>
</html>
